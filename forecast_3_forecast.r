# This script reads the bootstrapped mean of:
# 1. Ex post additionality (boot_additionality_[proj].csv)
# 2. Historical project carbon loss rate (boot_project_closs_rate_[proj].csv)
# 3. Historical regional carbon loss rates (boot_regional_closs_rate_[proj].csv)
# generates simple project-based and region-based forecasts as well as mixed forecasts using different historical periods,
# and compares and visualises their performance over different target periods

# It requires the following input variables:
#1. out_path: absolute path (plus prefix) of files generated by this repo, including in forecast_1_setup.r
#2. fig_path: absolute path (plus prefix) of the output figures

rm(list = ls())

#Load packages
library(tidyverse) #ggplot2, dplyr, and stringr used in plotPlacebo/plotBaseline.r: tibble to store labels with bquote()
library(magrittr) #pipe operators
library(corrplot) #corrplot::corrplot
library(MASS) #MASS::stepAIC
library(vegan) #vegan::varpart
library(eulerr) #eulerr::euler
library(Metrics) #Metrics::mae
library(patchwork)


#Define input variables
out_path = "/maps/epr26/ex_ante_forecast_out/out_ongoing" #path of files generated by this repo
fig_path = "/maps/epr26/ex_ante_forecast_out/out_" #path of output figures

project_var = read.csv(paste0(out_path, "_project_var_complete.csv"), header = T) %>%
  arrange(code)
projects = project_var$ID
t0_vec = project_var$t0
area_ha_vec = project_var$area_ha
cdens_list = project_var %>%
  dplyr::select(ID, cdens_1:cdens_6) %>%
  pivot_longer(cdens_1:cdens_6, names_to = "land.use.class", names_prefix = "cdens_", values_to = "carbon.density") %>%
  split(f = .$ID)

#Load data
cf_closs_boot_df = read.csv(paste0(out_path, "_boot_cf_closs.csv"), header = T)
additionality_boot_df = read.csv(paste0(out_path, "_boot_additionality.csv"), header = T)
ante_project_boot_df = read.csv(paste0(out_path, "_boot_project_closs_rate.csv"), header = T)
ante_region_boot_df = read.csv(paste0(out_path, "_boot_regional_closs_rate.csv"), header = T)

cf_closs_boot_list = group_split(cf_closs_boot_df, project)
additionality_boot_list = group_split(additionality_boot_df, project)
ante_project_boot_list = group_split(ante_project_boot_df, project)
ante_region_boot_list = group_split(ante_region_boot_df, project)

#Express year in relative terms to project start
cf_closs_boot_rel = lapply(seq_along(projects), function(i) {
  cf_closs_boot_list[[i]] %<>%
    mutate(year = year - t0_vec[i])
}) %>%
  list_rbind()

additionality_boot_rel = lapply(seq_along(projects), function(i) {
  additionality_boot_list[[i]] %<>%
    mutate(year = year - t0_vec[i])
}) %>%
  list_rbind()

ante_project_boot_rel = lapply(seq_along(projects), function(i) {
  ante_project_boot_list[[i]] %<>%
    mutate(year = year - t0_vec[i])
}) %>%
  list_rbind()

ante_region_boot_rel = lapply(seq_along(projects), function(i) {
  ante_region_boot_list[[i]] %<>%
    mutate(year = year - t0_vec[i])
}) %>%
  list_rbind()


#Generate simple forecasts from project or regional rates using different historical periods
forecast_prj_list = vector("list", 10 * length(projects))
forecast_reg_list = vector("list", 10 * length(projects))
for(i in 1:10) {
  yr_i = i - 11
  for(k in seq_along(projects)) {
    project_k = projects[k]
    ind = (i - 1) * length(projects) + k

    #observed counterfactual carbon loss rates
    obs_cf_closs = cf_closs_boot_rel %>%
      filter(year <= 10 & project == project_k) %>%
      pull(mean)
    if(length(obs_cf_closs) < 10) obs_cf_closs = c(obs_cf_closs, rep(NA, 10 - length(obs_cf_closs)))

    #project-based forecasts
    rate_project = ante_project_boot_rel %>%
      filter(year == yr_i & project == project_k) %>%
      pull(mean)
    forecast_prj_list[[ind]] = data.frame(project_used = yr_i, project = project_k, year = 1:10,
                                          forecast = rate_project, obs_cf_closs = obs_cf_closs[1:10], obs_add = obs_add[1:10],
                                          type = "project")

    #region-based forecasts
    rate_region = ante_region_boot_rel %>%
      filter(year == yr_i & project == project_k) %>%
      pull(mean)
    forecast_reg_list[[ind]] = data.frame(region_used = yr_i, project = project_k, year = 1:10,
                                          forecast = rate_region, obs_cf_closs = obs_cf_closs[1:10], obs_add = obs_add[1:10],
                                          type = "region")
  }
}
forecast_prj = list_rbind(forecast_prj_list)
forecast_reg = list_rbind(forecast_reg_list)


#Generate mixed forecasts from project and regional rates using different historical periods
forecast_mix_list = vector("list", 10 * 10 * length(projects))
for(i in 1:10) {
  yr_i = i - 11
  for(j in 1:10) {
    yr_j = j - 11
    for(k in seq_along(projects)) {
      project_k = projects[k]
      ind = (i - 1) * 10 * length(projects) + (j - 1) * length(projects) + k

      #observed counterfactual carbon loss rates
      obs_cf_closs = cf_closs_boot_rel %>%
        filter(year <= 10 & project == project_k) %>%
        pull(mean)
      if(length(obs_cf_closs) < 10) obs_cf_closs = c(obs_cf_closs, rep(NA, 10 - length(obs_cf_closs)))

      #observed carbon credit generation rates
      obs_add = additionality_boot_rel %>%
        filter(year <= 10 & project == project_k) %>%
        pull(mean)
      if(length(obs_add) < 10) obs_add = c(obs_add, rep(NA, 10 - length(obs_add)))

      #mixed forecasts using project and regional rates
      rate_project = ante_project_boot_rel %>%
        filter(year == yr_i & project == project_k) %>%
        pull(mean)
      rate_region = ante_region_boot_rel %>%
        filter(year == yr_j & project == project_k) %>%
        pull(mean)
      rate_mixed = ((rate_project ^ (9:0)) * (rate_region ^ (0:9))) ^ (1 / 10)

      forecast_mix_list[[ind]] = data.frame(project_used = yr_i, region_used = yr_j, project = project_k, year = 1:10,
                                            forecast = rate_mixed, obs_cf_closs = obs_cf_closs[1:10], obs_add = obs_add[1:10],
                                            type = "mixed")
    }
  }
}
forecast_mix = list_rbind(forecast_mix_list)


#Calculate forecast performance as R2 of linear regression model of observed carbon loss ~ forecast
forecast_prj_summ = forecast_prj %>%
  group_by(project_used, year) %>%
  summarise(r2 = summary(lm(obs_cf_closs ~ forecast))$r.squared,
            mae = mean(abs(forecast - obs_cf_closs), na.rm = T),
            bias = mean(forecast - obs_cf_closs, na.rm = T)) %>%
  ungroup() %>%
  mutate(type = "Project")
forecast_reg_summ = forecast_reg %>%
  group_by(region_used, year) %>%
  summarise(r2 = summary(lm(obs_cf_closs ~ forecast))$r.squared,
            mae = mean(abs(forecast - obs_cf_closs), na.rm = T),
            bias = mean(forecast - obs_cf_closs, na.rm = T)) %>%
  ungroup() %>%
  mutate(type = "Region")
forecast_mix_summ = forecast_mix %>%
  group_by(project_used, region_used, year) %>%
  summarise(r2 = summary(lm(obs_cf_closs ~ forecast))$r.squared,
            mae = mean(abs(forecast - obs_cf_closs), na.rm = T),
            bias = mean(forecast - obs_cf_closs, na.rm = T)) %>%
  ungroup() %>%
  mutate(type = "Mixed")

write.csv(forecast_prj, paste0(out_path, "_forecast_1_prj.csv"), row.names = F)
write.csv(forecast_reg, paste0(out_path, "_forecast_2_reg.csv"), row.names = F)
write.csv(forecast_mix, paste0(out_path, "_forecast_3_mix.csv"), row.names = F)
write.csv(forecast_prj_summ, paste0(out_path, "_forecast_summ_1_prj.csv"), row.names = F)
write.csv(forecast_reg_summ, paste0(out_path, "_forecast_summ_2_reg.csv"), row.names = F)
write.csv(forecast_mix_summ, paste0(out_path, "_forecast_summ_3_mix.csv"), row.names = F)

forecast_prj = read.csv(paste0(out_path, "_forecast_1_prj.csv"), header = T)
forecast_reg = read.csv(paste0(out_path, "_forecast_2_reg.csv"), header = T)
forecast_mix = read.csv(paste0(out_path, "_forecast_3_mix.csv"), header = T)
forecast_prj_summ = read.csv(paste0(out_path, "_forecast_summ_1_prj.csv"), header = T)
forecast_reg_summ = read.csv(paste0(out_path, "_forecast_summ_2_reg.csv"), header = T)
forecast_mix_summ = read.csv(paste0(out_path, "_forecast_summ_3_mix.csv"), header = T)


#Plot and compare overall forecasting performances of three approaches
axis_label_prj = expression(paste("Start of historical period for project rates (years before ", italic(t[0]), ")", sep = ""))
axis_label_reg = expression(paste("Start of historical period for regional rates (years before ", italic(t[0]), ")", sep = ""))
axis_label_target = expression(paste("End of target period (years after ", italic(t[0]), ")", sep = ""))

forecast_aggr = bind_rows(forecast_prj_summ, forecast_reg_summ, forecast_mix_summ) %>%
  relocate(region_used, .after = project_used)

#Figure 5. r2, MAE and bias (mean and range) for each type of forecasts across all target periods
figure5_list = vector("list", 0)
for(var in c("r2", "mae", "bias")) {
  figtitle = switch(var,
                    "r2" = expression("A. Coefficient of determination (R"^2*")"),
                    "mae" = expression("B. Mean absolute error (MAE)"),
                    "bias" = expression("C. Predictive bias"))
  figname = switch(var,
                   "r2" = "figure5a_overall_r2.png",
                   "mae" = "figure5b_overall_mae.png",
                   "bias" = "figure5c_overall_bias.png")
  y_scale = switch(var,
             "r2" = seq(0, 0.75, 0.25),
             "mae" = seq(0, 1.2, 0.2),
             "bias" = round(seq(-1.25, 0.75, 0.25), 2))
  y_label = switch(var,
             "r2" = expression(R^2),
             "mae" = expression(MAE),
             "bias" = expression(Bias))

  forecast_aggr_summ = forecast_aggr %>%
    dplyr::select(any_of(c("type", var, "year"))) %>%
    group_by(type, year) %>%
    summarise(mean = mean(.data[[var]], na.rm = T),
              min = min(.data[[var]], na.rm = T),
              max = max(.data[[var]], na.rm = T),
              lower = quantile(.data[[var]], 0.025, na.rm = T),
              upper = quantile(.data[[var]], 0.975, na.rm = T)) %>%
    ungroup() %>%
    mutate(type = factor(type, levels = c("Project", "Region", "Mixed")))

  figure5_list[[var]] = ggplot(data = forecast_aggr_summ, aes(x = year, y = mean)) +
    geom_line(aes(color = type), linewidth = 2) +
    geom_ribbon(aes(ymin = min, ymax = max, fill = type), alpha = 0.1) +
    scale_color_manual(values = c("#40B0A6", "#CDAC60", "#9467BD")) +
    scale_fill_manual(values = c("#40B0A6", "#CDAC60", "#9467BD")) +
    scale_x_continuous(breaks = 1:10, labels = 1:10) +
    scale_y_continuous(breaks = y_scale, labels = y_scale) +
    labs(title = figtitle, x = "Number of years afte project start", y = y_label,
         color = "Forecast type", fill = "Forecast type") +
    theme_bw() +
    theme(panel.grid = element_blank(),
          plot.title = element_text(size = 28, hjust = 0.5),
          axis.title = element_text(size = 26),
          axis.text = element_text(size = 24),
          axis.ticks = element_line(linewidth = 1),
          axis.ticks.length = unit(0.2, "cm"),
          legend.title = element_text(size = 26),
          legend.text = element_text(size = 24),
          legend.key.size = unit(1.5, "cm"))
}

figure5_full = figure5_list$r2 / figure5_list$mae / figure5_list$bias +
  plot_layout(guide = "collect", axes = "collect", axis_titles = "collect") &
  theme(legend.position = "bottom")
ggsave(paste0(fig_path, "figure5_overall.png"), width = 40, height = 60, unit = "cm")


#Determine the best forecasts using overall rankings of r2, MAE and bias for 5-year and 10-year forecasts
normalize = function(vec) {
  (vec - min(vec, na.rm = T)) / (max(vec, na.rm = T) - min(vec, na.rm = T))
}

forecast_aggr_rank_5 = forecast_aggr %>%
  filter(year == 5) %>%
  mutate(r2_rank = rank(-r2), mae_rank = rank(mae), bias_rank = rank(abs(bias)),
         r2_nmz = normalize(-r2), mae_nmz = normalize(mae), bias_nmz = normalize((abs(bias))))
forecast_aggr_rank_10 = forecast_aggr %>%
  filter(year == 10) %>%
  mutate(r2_rank = rank(-r2), mae_rank = rank(mae), bias_rank = rank(abs(bias)),
         r2_nmz = normalize(-r2), mae_nmz = normalize(mae), bias_nmz = normalize((abs(bias))))
forecast_aggr_rank = bind_rows(forecast_aggr_rank_5, forecast_aggr_rank_10) %>%
  pivot_wider(names_from = year,
              values_from = c(r2, mae, bias, r2_rank, mae_rank, bias_rank, r2_nmz, mae_nmz, bias_nmz),
              names_sep = "_") %>%
  mutate(sum_5 = r2_nmz_5 + mae_nmz_5 + bias_nmz_5,
         sum_10 = r2_nmz_10 + mae_nmz_10 + bias_nmz_10,
         sum_tot = sum_5 + sum_10,
         rank_sum_5 = r2_rank_5 + mae_rank_5 + bias_rank_5,
         rank_sum_10 = r2_rank_10 + mae_rank_10 + bias_rank_10,
         rank_sum_tot = sum_5 + sum_10) %>%
  mutate(rank_sum_5 = rank(sum_5),
         rank_sum_10 = rank(sum_10),
         rank_sum_tot = rank(sum_tot),
         rank_sum_rank_5 = rank(rank_sum_5),
         rank_sum_rank_10 = rank(rank_sum_10),
         rank_sum_rank_tot = rank(rank_sum_tot))
View(filter(forecast_aggr_rank, rank_sum_rank_5 <= 12))
View(filter(forecast_aggr_rank, rank_sum_rank_10 <= 12))
View(filter(forecast_aggr_rank, rank_sum_rank_tot <= 12))
View(filter(forecast_aggr_rank, rank_sum_5 <= 12))
View(filter(forecast_aggr_rank, rank_sum_10 <= 12))
View(filter(forecast_aggr_rank, rank_sum_tot <= 12))
#best forecast: mixed with project_used = -10 and region_used = -10

table_1 = forecast_aggr_rank %>%
  filter(rank_sum_rank_tot <= 12) %>%
  dplyr::select(project_used, region_used, type, r2_5, r2_10, mae_5, mae_10, bias_5, bias_10, rank_sum_rank_tot) %>%
  arrange(rank_sum_rank_tot)
write.csv(table_1, paste0(fig_path, "table_1.csv"), row.names = F)


#Linear model to predict carbon credit production over five-year and ten-year target periods
envir_var = project_var %>%
  dplyr::select(!c(country, t0, code) & !starts_with("cdens"))
envir_var_cor = cor(envir_var %>% dplyr::select(!ID))
corrplot(envir_var_cor, type = "lower", order = "hclust", addCoef.col = "black", diag = F)
#prj_ and reg_ environmental variables highly correlated: remove reg_
#slope and elevation highly correlated: remove elevation

envir_var = project_var %>%
  dplyr::select(!c(country, t0, code, prj_elev) & !starts_with("cdens") & !starts_with("reg_"))
envir_var_cor = cor(envir_var %>% dplyr::select(!ID))
corrplot(envir_var_cor, type = "lower", order = "hclust", addCoef.col = "black", diag = F)

forecast_best = forecast_mix %>%
  filter(project_used == -10 & region_used == -10 & year %in% c(5, 10)) %>%
  dplyr::select(!c(project_used, region_used, obs_cf_closs, type))

forecast_var = left_join(forecast_best, envir_var, join_by(project == ID))
forecast_var_scale = forecast_var %>%
  mutate_at(3:10, scale)

plots = vector("list", 2)
overall_summary = vector("list", 2)
for(i in 1:2) {
  yr_sel = c(5, 10)[i]
  figtitle = c("A. Five-year prediction", "B. Ten-year prediction")[i]
  data_sel = subset(forecast_var_scale, year == yr_sel)

  forecast_lm = lm(obs_add ~ . - project, data = data_sel)
  forecast_lm_sel = stepAIC(forecast_lm, direction = "backward", trace = 1) #dropped wgicc_mean, gdppc_rate, prj_remote
  lm_coef = coef(forecast_lm_sel)
  #Calculate Perform variance partitioning on historical forecast, project area, average slope, and GDP
  R2_full = summary(forecast_lm_sel)$adj.r.squared #adjusted R2 = 0.745
  vars = attr(terms(forecast_lm_sel), "term.labels")
  for(var_i in vars) {
    vars_new = setdiff(vars, var_i)
    new_formula = reformulate(vars_new, response = "obs_add")
    forecast_lm_min = lm(new_formula, data = data_sel)
    R2_incremental = R2_full - summary(forecast_lm_min)$adj.r.squared
    cat(var_i, ":", round(R2_incremental, 3), "\n")
  }

  #MAE
  forecast_mae = mean(abs(predict(forecast_lm_sel) - forecast_lm_sel$model$obs_add))

  #leave-one-out jackknife predictive bias
  bias = rep(NA, 20)
  for(j in 1:20) {
    forecast_lm_jk = lm(formula(forecast_lm_sel), data = data_sel[-j, ])
    pred_val = predict(forecast_lm_jk, data_sel[i, ], interval = "confidence")
    bias[j] = pred_val[, "fit"] - data_sel[j, ]$obs_add
  }

  overall_summary[[i]] = data.frame(year = yr_sel, R2 = R2_full, mae = forecast_mae, bias = mean(bias, na.rm = T))

  #Plot observed carbon credit production vs forecast of counterfactual carbon loss
  plots[[i]] = ggplot(data = subset(forecast_var, year == yr_sel)) +
    geom_point(aes(x = forecast, y = obs_add)) +
    geom_abline(intercept = 0, slope = 1, linetype = "dashed") +
    labs(title = figtitle,
        x = bquote(paste("Forecasted carbon credit production (MgC ", ha^-1, " ", yr^-1, ")")),
        y = bquote(paste("Observed carbon credit production (MgC ", ha^-1, " ", yr^-1, ")"))) +
    scale_x_continuous(limits = c(0, 1.5), breaks = seq(0, 1.5, 0.25)) +
    scale_y_continuous(limits = c(0, 1.5), breaks = seq(0, 1.5, 0.25)) +
    theme_bw() +
    theme(panel.grid = element_blank(),
          panel.spacing = unit(0, "cm"),
          plot.title = element_text(size = 28, hjust = 0.5),
          axis.title = element_text(size = 24),
          axis.text = element_text(size = 20),
          axis.ticks = element_blank(),
          legend.title = element_text(size = 24),
          legend.text = element_text(size = 20),
          legend.key.size = unit(1.5, "cm"))
}

overall_summary_df = list_rbind(overall_summary)
plot_all = plots[[1]] + plots[[2]] +
  plot_layout(axes = "collect", axis_titles = "collect")
ggsave(paste0(fig_path, "figure6_observed_vs_forecasted.png"), width = 60, height = 30, unit = "cm")



# Supplementary: se GAM to look at how forecast r2 changes with forecasting parameters ----
forecast_gam = mgcv::gam(r2 ~ s(project_used, bs = "tp", k = 10) +
                              s(region_used, bs = "tp", k = 10) +
                              s(year, bs = "tp", k = 10), data = forecast_mix_summ)
gam.check(forecast_gam)
summary(forecast_gam)
AIC(forecast_gam)


# -- Digression into discrepancy in GAM visualisation --

#variable "project_used": partial effects (line) and residuals (points) have the same pattern but are shifted
gam_plot = plot(forecast_gam, scale = 0, residuals = T, select = 1, cex = 5, shift = coef(forecast_gam)[1])

(gam_plot_gg = visreg(forecast_gam, "project_used", type = "conditional", partial = T, jitter = F, gg = T) +
    scale_x_continuous(breaks = c(-10, -5, -1)) +
    scale_y_continuous(limits = c(0.15, 0.6)) +
    labs(title = "Project carbon loss",
         x = "Interval start (year)",
         y = "Partial effect") +
    theme_bw() +
    theme(panel.grid = element_blank(),
          plot.title = element_text(size = 22, hjust = 0.5),
          axis.title = element_text(size = 20),
          axis.text = element_text(size = 18)))


#variable "year": here the predicted values dips into the negative when "year" is low, even though all observed values are positive
gam_plot = plot(forecast_gam, scale = 0, residuals = T, select = 3, cex = 5, shift = coef(forecast_gam)[1])

(gam_plot_gg = visreg(forecast_gam, "year", type = "conditional", partial = T, jitter = F, gg = T) +
    scale_x_continuous(breaks = c(1, 5, 10)) +
    labs(title = "Effect of forecasted interval",
         x = "Interval end (year)",
         y = "Partial effect") +
    theme_bw() +
    theme(panel.grid = element_blank(),
          plot.title = element_text(size = 24, hjust = 0.5),
          axis.title = element_text(size = 20),
          axis.text = element_text(size = 18)))

ddd = forecast_summ %>%
    mutate(pred = forecast_gam$fitted.values,
           resid = forecast_gam$residuals,
           resid_from_plot = gam_plot[[1]]$p.resid,
           resid_from_visreg = gam_plot_gg$data$y,
           resid_diff = resid_from_visreg - resid_from_plot)
ggplot(data = ddd, aes(x = project_used, y = resid)) + geom_point()
ggplot(data = ddd, aes(x = project_used, y = resid_from_plot)) + geom_point()
ggplot(data = ddd, aes(x = project_used, y = resid_from_plot - resid)) +
    geom_line() +
    scale_y_continuous(limits = c(-0.05, 0.05), breaks = c(-0.05, seq(-0.04, 0.04, by = 0.02), 0.05))
ggplot(data = ddd, aes(x = project_used, y = resid_from_visreg)) + geom_point()
ggplot(data = ddd, aes(x = project_used, y = resid_from_visreg - resid_from_plot)) +
    geom_line()
ggplot(data = ddd, aes(x = project_used, y = resid_diff)) + geom_point()
plot(forecast_gam, scale = 0, select = 1, ylim = c(-0.05, 0.05))

pred_df = data.frame(project_used = -5.5, region_used = -5.5, year = seq(1, 10, len = 500))
pred_response = predict(forecast_gam, pred_df, type = "response")
pred_df = pred_df %>%
    mutate(response = pred_response)
ggplot(data = pred_df, aes(x = year, y = response)) +
    geom_line() +
    scale_y_continuous(limits = c(0.15, 0.6))

#residuals in gamObject (fitted GAM object): working residuals for the fitted model
#forecast_gam$fitted.values + forecast_gam$residuals = observed values
#p.resid in plot.gam output object: partial residuals (working residuals + partial effect)
#the shift argument in plot.gam doesn't change output of partial residuals (p.resid)
#visreg generates the predictions as from plot.gam and predict.gam(type = "response") and mean covariates
#the partial residuals in visreg also follow the same pattern as p.resid in plot.gam output object, but with a difference of 0.4138:
#my guess is that visreg includes the intercept coefficient 0.3215 but p.resid does not (even though it is included on the plot due to the shift argument),
#but removing the intercept coefficient leaves the difference of 0.09237 (which seems to be the gap shown on the graphs)
#where does this come from?

# -- End of digression --

# Plot partial effects of fitted GAM (ignoring the digression) ----
plot_proj = visreg(forecast_gam, "project_used", type = "conditional", partial = T, jitter = F, gg = T) +
    scale_x_continuous(breaks = c(-10, -5, -1)) +
    scale_y_continuous(limits = c(0.15, 0.6)) +
    labs(title = "Project carbon loss",
         x = "Interval start (year)",
         y = "Partial effect") +
    theme_bw() +
    theme(panel.grid = element_blank(),
          plot.title = element_text(size = 22, hjust = 0.5),
          axis.title = element_text(size = 20),
          axis.text = element_text(size = 18))
plot_reg = visreg(forecast_gam, "region_used", type = "conditional", partial = T, jitter = T, gg = T) +
    scale_x_continuous(breaks = c(-10, -5, -1)) +
    labs(title = "Regional carbon loss",
         x = "Interval start (year)",
         y = "Partial effect") +
    theme_bw() +
    theme(panel.grid = element_blank(),
          plot.title = element_text(size = 22, hjust = 0.5),
          axis.title = element_text(size = 20),
          axis.text = element_text(size = 18))
plot_year = visreg(forecast_gam, "year", type = "conditional", partial = T, jitter = T, gg = T) +
    scale_x_continuous(breaks = c(1, 5, 10)) +
    labs(title = "Effect of forecasted interval",
         x = "Interval end (year)",
         y = "Partial effect") +
    theme_bw() +
    theme(panel.grid = element_blank(),
          plot.title = element_text(size = 24, hjust = 0.5),
          axis.title = element_text(size = 20),
          axis.text = element_text(size = 18))

title_forecasting = ggplot() +
    ggtitle("Effect of forecasting interval chosen to estimate:") +
    theme_void() + theme(plot.title = element_text(size = 24, hjust = 0.5, margin = margin(t = 10)))

#use patchwork to combine plots
design = "AAAAAAAAAA
          BBBBBBBBBB
          ##CCCCC###"
plot_forecasting = (plot_proj + plot_reg) +
    plot_layout(axis_titles = "collect_y")
(plot_all = title_forecasting / plot_forecasting / plot_year +
    plot_layout(design = design, heights = c(0.02, 1, 1)))
ggsave(plot_all, filename = paste0(fig_path, "forecast_5_gam_summ.png"), width = 30, height = 30, unit = "cm")