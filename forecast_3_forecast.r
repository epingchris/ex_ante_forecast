# This script reads the bootstrapped mean of:
# 1. Ex post additionality (boot_additionality_[proj].csv)
# 2. Historical project carbon loss rate (boot_project_closs_rate_[proj].csv)
# 3. Historical regional carbon loss rates (boot_regional_closs_rate_[proj].csv)
# generates simple project-based and region-based forecasts as well as mixed forecasts using different historical periods,
# and compares and visualises their performance over different target periods

# It requires the following input variables:
#1. out_path: absolute path (plus prefix) of files generated by this repo, including in forecast_1_setup.r
#2. fig_path: absolute path (plus prefix) of the output figures

rm(list = ls())

#Load packages
library(tidyverse) #ggplot2, dplyr, and stringr used in plotPlacebo/plotBaseline.r: tibble to store labels with bquote()
library(magrittr) #pipe operators
library(parallel) #detectCores()
library(future) #parallelise lapply() : future_lapply()
library(future.apply) #parallelise lapply(): future_lapply()
library(corrplot) #corrplot::corrplot
library(MASS) #MASS::stepAIC
library(vegan) #vegan::varpart
library(eulerr) #eulerr::euler
library(Metrics) #Metrics::mae
library(patchwork)
library(gridExtra)
library(grid) #grid::textGrob, grid::gpar

#Set parallelise plan
plan(multisession, workers = 20)

#Min-max normalization function
rescale01 = function(vec) {
  (vec - min(vec, na.rm = T)) / (max(vec, na.rm = T) - min(vec, na.rm = T))
}
MAPE = function(forecast, observed) {
  return(mean(abs(forecast - observed) / abs(observed), na.rm = T) * 100)
}
MPB = function(forecast, observed) {
  return(mean((forecast - observed) / observed, na.rm = T) * 100)
}

#Define input variables
out_path = "/maps/epr26/ex_ante_forecast_out/out_ongoing" #path of files generated by this repo
fig_path = "/maps/epr26/ex_ante_forecast_out/out_" #path of output figures

project_var = read.csv(paste0(out_path, "_project_var.csv"), header = T)
projects = project_var$ID
t0_vec = project_var$t0
area_ha_vec = project_var$area_ha
cdens_list = project_var %>%
  dplyr::select(ID, cdens_1:cdens_6) %>%
  pivot_longer(cdens_1:cdens_6, names_to = "land.use.class", names_prefix = "cdens_", values_to = "carbon.density") %>%
  split(f = .$ID)

#Trying: load data with all bootstrap samples
additionality_list = vector("list", length(projects))
closs_observed_list = vector("list", length(projects))
closs_project_list = vector("list", length(projects))
closs_region_list = vector("list", length(projects))

forecast = future.apply(seq_along(projects), function(i) {
  t0 = t0_vec[i]
  project_i = projects[i]
  additionality_list[[i]] = read.csv(paste0(out_path, "_additionality_", projects[i], ".csv"), header = T) %>%
      mutate(year = year - t0)
  closs_observed_list[[i]] = read.csv(paste0(out_path, "_closs_observed_", projects[i], ".csv"), header = T) %>%
      mutate(year = year - t0)
  closs_project_list[[i]] = read.csv(paste0(out_path, "_closs_project_", projects[i], ".csv"), header = T) %>%
      mutate(year = year - t0)
  closs_region_list[[i]] = read.csv(paste0(out_path, "_closs_regional_", projects[i], ".csv"), header = T) %>%
      mutate(year = year - t0)
})

for(i in seq_along(projects)) {
  t0 = t0_vec[i]
  project_i = projects[i]
  additionality_list[[i]] = read.csv(paste0(out_path, "_additionality_", projects[i], ".csv"), header = T) %>%
      mutate(period_target = year - t0) %>%
      dplyr::select(pair, cdens_boot, period_target, additionality_arith) %>%
      filter(period_target <= 10 & period_target > 0) %>%
      group_by(pair, cdens_boot) %>% 
      complete(period_target = 1:10, fill = list(additionality_arith = NA_real_)) %>%
      fill(pair, cdens_boot, .direction = "downup") %>%  # carry values in both directions
      ungroup() %>%
      mutate(project = project_i)
  closs_observed_list[[i]] = read.csv(paste0(out_path, "_closs_observed_", projects[i], ".csv"), header = T) %>%
      mutate(period_target = year - t0) %>%
      dplyr::select(pair, cdens_boot, period_target, closs) %>%
      filter(period_target <= 10 & period_target > 0) %>%
      group_by(pair, cdens_boot) %>% 
      complete(period_target = 1:10, fill = list(closs = NA_real_)) %>%
      fill(pair, cdens_boot, .direction = "downup") %>%  # carry values in both directions
      ungroup() %>%
      mutate(project = project_i)
  closs_project_list[[i]] = read.csv(paste0(out_path, "_closs_project_", projects[i], ".csv"), header = T) %>%
      mutate(year = year - t0, project = project_i)
  closs_region_list[[i]] = read.csv(paste0(out_path, "_closs_regional_", projects[i], ".csv"), header = T) %>%
      mutate(year = year - t0, project = project_i)
}

additionality = list_rbind(additionality_list)
closs_observed  = list_rbind(closs_observed_list)
closs_project = list_rbind(closs_project_list)
closs_region = list_rbind(closs_region_list)


#Load data and express them as relative to project start
boot_add_arith = read.csv(paste0(out_path, "_boot_additionality_arith.csv"), header = T)
boot_add_geom = read.csv(paste0(out_path, "_boot_additionality_geom.csv"), header = T)
boot_closs_observed = read.csv(paste0(out_path, "_boot_closs_observed.csv"), header = T)
boot_closs_project = read.csv(paste0(out_path, "_boot_closs_project.csv"), header = T)
boot_closs_region = read.csv(paste0(out_path, "_boot_closs_regional.csv"), header = T)

boot_add_arith_list = vector("list", length(projects))
boot_add_geom_list = vector("list", length(projects))
boot_closs_observed_list = vector("list", length(projects))
boot_closs_project_list = vector("list", length(projects))
boot_closs_region_list = vector("list", length(projects))

for(i in seq_along(projects)) {
  t0 = t0_vec[i]
  project_i = projects[i]
  boot_add_arith_list[[i]] = boot_add_arith %>%
      filter(project == project_i) %>%
      mutate(year = year - t0)
  boot_add_geom_list[[i]] = boot_add_geom %>%
      filter(project == project_i) %>%
      mutate(year = year - t0)
  boot_closs_observed_list[[i]] = boot_closs_observed %>%
      filter(project == project_i) %>%
      mutate(year = year - t0)
  boot_closs_project_list[[i]] = boot_closs_project %>%
      filter(project == project_i) %>%
      mutate(year = year - t0)
  boot_closs_region_list[[i]] = boot_closs_region %>%
      filter(project == project_i) %>%
      mutate(year = year - t0)
}

boot_add_arith_rel = list_rbind(boot_add_arith_list)
boot_add_geom_rel = list_rbind(boot_add_geom_list)
boot_closs_observed_rel = list_rbind(boot_closs_observed_list)
boot_closs_project_rel = list_rbind(boot_closs_project_list)
boot_closs_region_rel = list_rbind(boot_closs_region_list)

#Reformat data of observed counterfactual carbon loss rates and make sure every project has 10 years of data
observed = boot_closs_observed_rel %>%
  filter(year <= 10) %>%
  rename(period_target = year, rate_obs = mean) %>%
  complete(project, period_target = 1:10, fill = list(rate_obs = NA_real_))

observed_add_arith = boot_add_arith_rel %>%
  filter(year <= 10) %>%
  rename(period_target = year, additionality = mean) %>%
  complete(project, period_target = 1:10, fill = list(additionality = NA_real_))

observed_add_geom = boot_add_geom_rel %>%
  filter(year <= 10) %>%
  rename(period_target = year, additionality = mean) %>%
  complete(project, period_target = 1:10, fill = list(additionality = NA_real_))


#Generate simple forecasts from project or regional rates using different historical periods
forecast_prj_list = vector("list", 10 * length(projects))
forecast_reg_list = vector("list", 10 * length(projects))
for(i in 1:10) {
  yr_i = i - 11
  for(k in seq_along(projects)) {
    project_k = projects[k]
    ind = (i - 1) * length(projects) + k

    #project-based forecasts
    rate_project = boot_closs_project_rel %>%
      filter(year == yr_i & project == project_k) %>%
      pull(mean)
    forecast_prj_list[[ind]] = data.frame(period_hist_prj = yr_i, period_hist_reg = NA, period_target = 1:10,
                                          forecast = rate_project, project = project_k)

    #region-based forecasts
    rate_region = boot_closs_region_rel %>%
      filter(year == yr_i & project == project_k) %>%
      pull(mean)
    forecast_reg_list[[ind]] = data.frame(period_hist_prj = NA, period_hist_reg = yr_i, period_target = 1:10,
                                          forecast = rate_region, project = project_k)
  }
}
forecast_prj = list_rbind(forecast_prj_list) %>%
  mutate(type = "Project")
forecast_reg = list_rbind(forecast_reg_list) %>%
  mutate(type = "Region")


#Generate mixed forecasts from project and regional rates using different historical periods
forecast_mix_list = vector("list", 10 * 10 * length(projects))
for(i in 1:10) {
  yr_i = i - 11
  for(j in 1:10) {
    yr_j = j - 11
    for(k in seq_along(projects)) {
      project_k = projects[k]
      ind = (i - 1) * 10 * length(projects) + (j - 1) * length(projects) + k

      #mixed forecasts using project and regional rates
      rate_project = boot_closs_project_rel %>%
        filter(year == yr_i & project == project_k) %>%
        pull(mean)
      rate_region = boot_closs_region_rel %>%
        filter(year == yr_j & project == project_k) %>%
        pull(mean)

      rate_mixed = ((rate_project ^ (9:0)) * (rate_region ^ (0:9))) ^ (1 / 10) #weighted geometric mean

      forecast_mix_list[[ind]] = data.frame(period_hist_prj = yr_i, period_hist_reg = yr_j, period_target = 1:10,
                                            forecast = rate_mixed, project = project_k)
    }
  }
}
forecast_mix = list_rbind(forecast_mix_list) %>%
  mutate(type = "Mixed")

# Merge with observed values
forecast_all = bind_rows(forecast_prj, forecast_reg, forecast_mix) %>%
  left_join(observed, by = c("project", "period_target"))

# Summarise forecasting performance
forecast_summ = forecast_all %>%
  group_by(period_hist_prj, period_hist_reg, period_target, type) %>%
  summarise(r2 = summary(lm(rate_obs ~ forecast))$r.squared,
            mae = mean(abs(forecast - rate_obs), na.rm = T),
            bias = mean(forecast - rate_obs, na.rm = T),
            mape = MAPE(forecast, rate_obs),
            mpb = MPB(forecast, rate_obs)) %>%
  ungroup()

write.csv(forecast_all, paste0(out_path, "_forecast.csv"), row.names = F)
write.csv(forecast_summ, paste0(out_path, "_forecast_summary.csv"), row.names = F)

forecast_all = read.csv(paste0(out_path, "_forecast.csv"), header = T)
forecast_summ_geom = read.csv(paste0(out_path, "_forecast_summary.csv"), header = T)


#Plot Figure 5. Overall forecasting performances (mean and range of r2, MAE and bias) for each type of forecasts across all target periods
figure5_list = vector("list", 0)
for(var in c("r2", "mape", "mpb")) {
  figtitle = switch(var,
                    "r2" = expression("A. Coefficient of determination (R"^2*")"),
                    "mae" = expression("B. Mean absolute error (MAE)"),
                    "bias" = expression("C. Mean bias"),
                    "mape" = expression("B. Mean absolute percentage error (MAPE)"),
                    "mpb" = expression("C. Mean percentage bias (MPB)"))
  y_scale = switch(var,
             "r2" = seq(0, 0.75, 0.25),
             "mae" = seq(0, 0.15, 0.05),
             "bias" = seq(-0.015, 0, 0.005),
             "mape" = seq(0, 350, 50),
             "mpb" = seq(-100, 300, 100))
  y_label = switch(var,
             "r2" = expression(R^2),
             "mae" = expression(MAE),
             "bias" = expression(Bias),
             "mape" = expression(`MAPE (%)`),
             "mpb" = expression(`MPB (%)`))

  forecast_summ_plot = forecast_summ %>%
    dplyr::select(any_of(c("type", var, "period_target"))) %>%
    group_by(type, period_target) %>%
    summarise(mean = mean(.data[[var]], na.rm = T),
              min = min(.data[[var]], na.rm = T),
              max = max(.data[[var]], na.rm = T),
              lower = quantile(.data[[var]], 0.025, na.rm = T),
              upper = quantile(.data[[var]], 0.975, na.rm = T)) %>%
    ungroup() %>%
    mutate(type = factor(type, levels = c("Project", "Region", "Mixed")))

  figure5_list[[var]] = ggplot(data = forecast_summ_plot, aes(x = period_target, y = mean)) +
    geom_line(aes(color = type), linewidth = 2) +
    geom_ribbon(aes(ymin = lower, ymax = upper, fill = type), alpha = 0.1) +
    scale_color_manual(values = c("#40B0A6", "#CDAC60", "#9467BD")) +
    scale_fill_manual(values = c("#40B0A6", "#CDAC60", "#9467BD")) +
    scale_x_continuous(breaks = 1:10, labels = 1:10) +
    scale_y_continuous(breaks = y_scale, labels = y_scale) +
    labs(title = figtitle, x = "Number of years afte project start", y = y_label,
         color = "Forecast type", fill = "Forecast type") +
    theme_bw() +
    theme(panel.grid = element_blank(),
          plot.title = element_text(size = 28, hjust = 0.5),
          axis.title = element_text(size = 26),
          axis.text = element_text(size = 24),
          axis.ticks = element_line(linewidth = 1),
          axis.ticks.length = unit(0.2, "cm"),
          legend.title = element_text(size = 26),
          legend.text = element_text(size = 24),
          legend.key.size = unit(1.5, "cm"))
}

figure5_full = figure5_list[[1]] / figure5_list[[2]] / figure5_list[[3]] +
  plot_layout(guide = "collect", axes = "collect", axis_titles = "collect") &
  theme(legend.position = "bottom")

ggsave(paste0(fig_path, "figure5_perc.png"), width = 40, height = 60, unit = "cm")


#Determine the best forecasts using overall rankings of r2, MAPE and MPB for 5-year and 10-year forecasts
forecast_summ_5 = forecast_summ %>%
  dplyr::select(!any_of(c("mae", "bias"))) %>%
  filter(period_target == 5) %>%
  mutate(r2_rank = rank(-r2, na.last = NA), mape_rank = rank(mape, na.last = NA), mpb_rank = rank(abs(mpb), na.last = NA),
         r2_nmz = rescale01(-r2), mape_nmz = rescale01(mape), mpb_nmz = rescale01((abs(mpb))))
forecast_summ_10 = forecast_summ %>%
  dplyr::select(!any_of(c("mae", "bias"))) %>%
  filter(period_target == 10) %>%
  mutate(r2_rank = rank(-r2, na.last = NA), mape_rank = rank(mape, na.last = NA), mpb_rank = rank(abs(mpb), na.last = NA),
         r2_nmz = rescale01(-r2), mape_nmz = rescale01(mape), mpb_nmz = rescale01((abs(mpb))))
forecast_summ_rank = bind_rows(forecast_summ_5, forecast_summ_10) %>%
  pivot_wider(names_from = period_target,
              values_from = c(r2, mape, mpb, r2_rank, mape_rank, mpb_rank, r2_nmz, mape_nmz, mpb_nmz),
              names_sep = "_") %>%
  mutate(sum_rank = r2_rank_5 + mape_rank_5 + mpb_rank_5 + r2_rank_10 + mape_rank_10 + mpb_rank_10)
filter(forecast_summ_rank, sum_rank <= quantile(sum_rank, 0.1, na.rm = T))
#best forecast: mixed with project_used = -10 and region_used = -7

table_1 = forecast_summ_rank %>%
  filter(sum_rank <= quantile(sum_rank, 0.1, na.rm = T)) %>%
  dplyr::select(period_hist_prj, period_hist_reg, type, r2_5, r2_10, mape_5, mape_10, mpb_5, mpb_10, sum_rank) %>%
  arrange(sum_rank)
write.csv(table_1, paste0(fig_path, "table_1.csv"), row.names = F)


#Linear model to predict carbon credit production over five-year and ten-year target periods
envir_var = project_var %>%
  dplyr::select(!c(country, t0, code) & !starts_with(c("cdens", "n_", "se_")))
envir_var_cor = cor(envir_var %>% dplyr::select(!ID))
corrplot(envir_var_cor, type = "lower", order = "hclust", addCoef.col = "black", diag = F)
#prj_ and reg_ environmental variables highly correlated: remove reg_
#slope and elevation highly correlated: remove elevation

envir_var = project_var %>%
  dplyr::select(!c(country, t0, code, prj_elev) & !starts_with(c("cdens", "n_", "se_", "reg_")))
envir_var_cor = cor(envir_var %>% dplyr::select(!ID))
corrplot(envir_var_cor, type = "lower", order = "hclust", addCoef.col = "black", diag = F)

forecast_var = forecast_all %>%
  filter(period_hist_prj == -10 & period_hist_reg == -7 & period_target %in% c(5, 10)) %>%
  dplyr::select(c(period_target, forecast, project)) %>%
  pivot_wider(names_from = "period_target", values_from = "forecast", names_prefix = "forecast_")

observed_var = observed_add_geom %>%
  filter(period_target %in% c(5, 10)) %>%
  dplyr::select(c(period_target, project, additionality)) %>%
  pivot_wider(names_from = "period_target", values_from = "additionality", names_prefix = "additionality_")

model_df = left_join(forecast_var, envir_var, join_by(project == ID)) %>%
  left_join(observed_var, ., join_by(project == project))
model_df_scaled = model_df %>%
  mutate_at(vars(-c("project", "additionality_5", "additionality_10")), ~ as.numeric(scale(.))) #scale and center all predictor columns except project


#Plot observed vs predicted carbon credit production for 5-year and 10-year forecasts
plots_full = vector("list", 2)
plots_naive = vector("list", 2)
plots_sel = vector("list", 2)
effects_full = vector("list", 2)
effects_sel = vector("list", 2)
R2_df = as.data.frame(matrix(nrow = 2, ncol = 3)) %>% set_colnames(c("full", "naive", "sel")) %>% set_rownames(c("5", "10"))
mape_df = as.data.frame(matrix(nrow = 2, ncol = 3)) %>% set_colnames(c("full", "naive", "sel")) %>% set_rownames(c("5", "10"))
mpb_df = as.data.frame(matrix(nrow = 2, ncol = 3)) %>% set_colnames(c("full", "naive", "sel")) %>% set_rownames(c("5", "10"))

for(i in 1:2) {
  yr_sel = c(5, 10)[i]
  yr_excl = c(10, 5)[i]
  figtitle = c("Five-year prediction", "Ten-year prediction")[i]
  model_df_selected = model_df_scaled %>%
    dplyr::select(!project & !ends_with(as.character(yr_excl))) %>%
    rename(additionality = colnames(.)[1], forecast = colnames(.)[2])

  forecast_lm_full = lm(additionality ~ ., data = model_df_selected) #full model
  forecast_lm_naive = lm(additionality ~ forecast, data = model_df_selected) #naive model: only forecast of counterfactual carbon loss as predictor
  forecast_lm_sel = stepAIC(forecast_lm_full, direction = "backward", trace = 1) #backward selection
  R2_full = summary(forecast_lm_full)$adj.r.squared
  R2_naive = summary(forecast_lm_naive)$adj.r.squared
  R2_sel = summary(forecast_lm_sel)$adj.r.squared
  R2_df[rownames(R2_df) == yr_sel, ] = c(R2_full, R2_naive, R2_sel)

  par(mfrow = c(2, 2))
  png(paste0(fig_path, "figure6_diagnostic_", yr_sel, "_full.png"), width = 600, height = 600)
  plot(forecast_lm_full)
  dev.off()
  png(paste0(fig_path, "figure6_diagnostic_", yr_sel, "_naive.png"), width = 600, height = 600)
  plot(forecast_lm_naive)
  dev.off()
  png(paste0(fig_path, "figure6_diagnostic_", yr_sel, "_sel.png"), width = 600, height = 600)
  plot(forecast_lm_sel)
  dev.off()

  #Retrieve coefficients and calculate incremental R2 of each predictor in selected model
  effects_full[[i]] = as.data.frame(summary(forecast_lm_full)$coefficients)
  vars = attr(terms(forecast_lm_full), "term.labels")
  if(length(vars) > 1) {
    incr_r2 = NA
    for(var_i in vars) {
      vars_new = setdiff(vars, var_i)
      new_formula = reformulate(vars_new, response = "additionality")
      forecast_lm_min = lm(new_formula, data = model_df_selected)
      incr_r2 = c(incr_r2, R2_full - summary(forecast_lm_min)$adj.r.squared)
    }
    effects_full[[i]]$incr_r2 = incr_r2
  }

  effects_sel[[i]] = as.data.frame(summary(forecast_lm_sel)$coefficients)
  vars = attr(terms(forecast_lm_sel), "term.labels")
  if(length(vars) > 1) {
    incr_r2 = NA
    for(var_i in vars) {
      vars_new = setdiff(vars, var_i)
      new_formula = reformulate(vars_new, response = "additionality")
      forecast_lm_min = lm(new_formula, data = model_df_selected)
      incr_r2 = c(incr_r2, R2_sel - summary(forecast_lm_min)$adj.r.squared)
    }
    effects_sel[[i]]$incr_r2 = incr_r2
  }

  #Calculate predictions
  pred_df = data.frame(pred_full = predict(forecast_lm_full),
                       pred_naive = predict(forecast_lm_naive),
                       pred_sel = predict(forecast_lm_sel),
                       observed = forecast_lm_full$model$additionality)

  #Calculate mean absolute percentage error (MAPE)
  mape_full = MAPE(pred_df$pred_full, pred_df$observed)
  mape_naive = MAPE(pred_df$pred_naive, pred_df$observed)
  mape_sel = MAPE(pred_df$pred_sel, pred_df$observed)
  mape_df[rownames(mape_df) == yr_sel, ] = c(mape_full, mape_naive, mape_sel)

  #Calculate mean percentage bias (MPB)
  mpb_full = MPB(pred_df$pred_full, pred_df$observed)
  mpb_naive = MPB(pred_df$pred_naive, pred_df$observed)
  mpb_sel = MPB(pred_df$pred_sel, pred_df$observed)
  mpb_df[rownames(mpb_df) == yr_sel, ] = c(mpb_full, mpb_naive, mpb_sel)

  #Plot original model (observed carbon credit production vs predicted carbon credit production)
  plots_full[[i]] = ggplot(data = pred_df) +
    geom_point(aes(x = pred_full, y = observed), size = 3) +
    geom_abline(intercept = 0, slope = 1, linetype = "dashed") +
    annotate(geom = "text", x = 1, y = 0.3, size = 10,
             label = bquote(paste(R^2, " = ", .(round(R2_full, 3))))) +
    annotate(geom = "text", x = 1, y = 0.2, size = 10,
             label = bquote(paste("MAPE: ", .(round(mape_full, 3))))) +
    annotate(geom = "text", x = 1, y = 0.1, size = 10,
             label = bquote(paste("MPB: ", .(round(mpb_full, 3))))) +
    labs(title = figtitle,
         x = bquote(paste("Predicted carbon credit production (MgC ", ha^-1, " ", yr^-1, ")")),
         y = "") +
    scale_x_continuous(limits = c(0, 1.5), breaks = seq(0, 1.5, 0.25)) +
    scale_y_continuous(limits = c(0, 1.5), breaks = seq(0, 1.5, 0.25)) +
    theme_bw() +
    theme(panel.grid = element_blank(),
          panel.spacing = unit(0, "cm"),
          plot.title = element_text(size = 32, hjust = 0.5),
          axis.title.x = element_blank(),
          axis.text.x = element_blank(),
          axis.title.y = element_text(size = 28),
          axis.text.y = element_text(size = 24),
          axis.ticks = element_blank(),
          axis.line = element_line(color = "black"))


  #Plot naive model (observed carbon credit production vs forecast of counterfactual carbon loss)
  plots_naive[[i]] = ggplot(data = pred_df) +
    geom_point(aes(x = pred_naive, y = observed), size = 3) +
    geom_abline(intercept = 0, slope = 1, linetype = "dashed") +
    annotate(geom = "text", x = 1, y = 0.3, size = 10,
             label = bquote(paste(R^2, " = ", .(round(R2_naive, 3))))) +
    annotate(geom = "text", x = 1, y = 0.2, size = 10,
             label = bquote(paste("MAPE: ", .(round(mape_naive, 3))))) +
    annotate(geom = "text", x = 1, y = 0.1, size = 10,
             label = bquote(paste("MPB: ", .(round(mpb_naive, 3))))) +
    labs(title = figtitle,
         x = bquote(paste("Predicted carbon credit production (MgC ", ha^-1, " ", yr^-1, ")")),
         y = "") +
    # scale_x_continuous(limits = c(-0.5, 1.75), breaks = seq(-0.5, 1.75, 0.25)) +
    # scale_y_continuous(limits = c(-0.5, 1.75), breaks = seq(-0.5, 1.75, 0.25)) +
    scale_x_continuous(limits = c(0, 1.5), breaks = seq(0, 1.5, 0.25)) +
    scale_y_continuous(limits = c(0, 1.5), breaks = seq(0, 1.5, 0.25)) +
    theme_bw() +
    theme(panel.grid = element_blank(),
          panel.spacing = unit(0, "cm"),
          plot.title = element_text(size = 32, hjust = 0.5),
          axis.title = element_text(size = 28),
          axis.text = element_text(size = 24),
          axis.ticks = element_blank(),
          axis.line = element_line(color = "black"))


  #Plot selected model (observed carbon credit production vs predicted carbon credit production)
  plots_sel[[i]] = ggplot(data = pred_df) +
    geom_point(aes(x = pred_sel, y = observed), size = 3) +
    geom_abline(intercept = 0, slope = 1, linetype = "dashed") +
    annotate(geom = "text", x = 1, y = 0.3, size = 10,
             label = bquote(paste(R^2, " = ", .(round(R2_sel, 3))))) +
    annotate(geom = "text", x = 1, y = 0.2, size = 10,
             label = bquote(paste("MAPE: ", .(round(mape_sel, 3))))) +
    annotate(geom = "text", x = 1, y = 0.1, size = 10,
             label = bquote(paste("MPB: ", .(round(mpb_sel, 3))))) +
    labs(title = figtitle,
         x = bquote(paste("Predicted carbon credit production (MgC ", ha^-1, " ", yr^-1, ")")),
         y = "") +
    scale_x_continuous(limits = c(0, 1.5), breaks = seq(0, 1.5, 0.25)) +
    scale_y_continuous(limits = c(0, 1.5), breaks = seq(0, 1.5, 0.25)) +
    theme_bw() +
    theme(panel.grid = element_blank(),
          panel.spacing = unit(0, "cm"),
          plot.title = element_text(size = 32, hjust = 0.5),
          axis.title.x = element_blank(),
          axis.text.x = element_blank(),
          axis.title.y = element_text(size = 28),
          axis.text.y = element_text(size = 24),
          axis.ticks = element_blank(),
          axis.line = element_line(color = "black"))
}

plot_full_all = plots_full[[1]] + plots_full[[2]] +
  plot_layout(axes = "collect", axis_titles = "collect")
plot_full_title = wrap_elements(grid::textGrob("A. Full model", gp = gpar(fontsize = 36, fontface = "bold")))
plot_naive_all = plots_naive[[1]] + plots_naive[[2]] +
  plot_layout(axes = "collect", axis_titles = "collect")
plot_naive_title = wrap_elements(grid::textGrob("B. Naive model", gp = gpar(fontsize = 36, fontface = "bold")))
plot_sel_all = plots_sel[[1]] + plots_sel[[2]] +
  plot_layout(axes = "collect", axis_titles = "collect")
plot_sel_title = wrap_elements(grid::textGrob("C. Selected model", gp = gpar(fontsize = 36, fontface = "bold")))

plot_all = plot_full_title / plot_full_all / plot_naive_title / plot_naive_all / plot_sel_title / plot_sel_all +
  plot_layout(height = c(0.15, 1, 0.15, 1, 0.15, 1))
title_y = wrap_elements(grid::textGrob(bquote(paste("Observed carbon credit production (MgC ", ha^-1, " ", yr^-1, ")")),
                                       rot = 90, gp = gpar(fontsize = 28)))
plot_all = title_y + plot_all +
  plot_layout(width = c(0.02, 1))
plot_all
ggsave(paste0(fig_path, "figure6_observed_vs_forecasted.png"), width = 50, height = 75, unit = "cm")



# Supplementary: se GAM to look at how forecast r2 changes with forecasting parameters ----
forecast_gam = mgcv::gam(r2 ~ s(project_used, bs = "tp", k = 10) +
                              s(region_used, bs = "tp", k = 10) +
                              s(year, bs = "tp", k = 10), data = forecast_mix_summ)
gam.check(forecast_gam)
summary(forecast_gam)
AIC(forecast_gam)


# -- Digression into discrepancy in GAM visualisation --

#variable "project_used": partial effects (line) and residuals (points) have the same pattern but are shifted
gam_plot = plot(forecast_gam, scale = 0, residuals = T, select = 1, cex = 5, shift = coef(forecast_gam)[1])

(gam_plot_gg = visreg(forecast_gam, "project_used", type = "conditional", partial = T, jitter = F, gg = T) +
    scale_x_continuous(breaks = c(-10, -5, -1)) +
    scale_y_continuous(limits = c(0.15, 0.6)) +
    labs(title = "Project carbon loss",
         x = "Interval start (year)",
         y = "Partial effect") +
    theme_bw() +
    theme(panel.grid = element_blank(),
          plot.title = element_text(size = 22, hjust = 0.5),
          axis.title = element_text(size = 20),
          axis.text = element_text(size = 18)))


#variable "year": here the predicted values dips into the negative when "year" is low, even though all observed values are positive
gam_plot = plot(forecast_gam, scale = 0, residuals = T, select = 3, cex = 5, shift = coef(forecast_gam)[1])

(gam_plot_gg = visreg(forecast_gam, "year", type = "conditional", partial = T, jitter = F, gg = T) +
    scale_x_continuous(breaks = c(1, 5, 10)) +
    labs(title = "Effect of forecasted interval",
         x = "Interval end (year)",
         y = "Partial effect") +
    theme_bw() +
    theme(panel.grid = element_blank(),
          plot.title = element_text(size = 24, hjust = 0.5),
          axis.title = element_text(size = 20),
          axis.text = element_text(size = 18)))

ddd = forecast_summ %>%
    mutate(pred = forecast_gam$fitted.values,
           resid = forecast_gam$residuals,
           resid_from_plot = gam_plot[[1]]$p.resid,
           resid_from_visreg = gam_plot_gg$data$y,
           resid_diff = resid_from_visreg - resid_from_plot)
ggplot(data = ddd, aes(x = project_used, y = resid)) + geom_point()
ggplot(data = ddd, aes(x = project_used, y = resid_from_plot)) + geom_point()
ggplot(data = ddd, aes(x = project_used, y = resid_from_plot - resid)) +
    geom_line() +
    scale_y_continuous(limits = c(-0.05, 0.05), breaks = c(-0.05, seq(-0.04, 0.04, by = 0.02), 0.05))
ggplot(data = ddd, aes(x = project_used, y = resid_from_visreg)) + geom_point()
ggplot(data = ddd, aes(x = project_used, y = resid_from_visreg - resid_from_plot)) +
    geom_line()
ggplot(data = ddd, aes(x = project_used, y = resid_diff)) + geom_point()
plot(forecast_gam, scale = 0, select = 1, ylim = c(-0.05, 0.05))

pred_df = data.frame(project_used = -5.5, region_used = -5.5, year = seq(1, 10, len = 500))
pred_response = predict(forecast_gam, pred_df, type = "response")
pred_df = pred_df %>%
    mutate(response = pred_response)
ggplot(data = pred_df, aes(x = year, y = response)) +
    geom_line() +
    scale_y_continuous(limits = c(0.15, 0.6))

#residuals in gamObject (fitted GAM object): working residuals for the fitted model
#forecast_gam$fitted.values + forecast_gam$residuals = observed values
#p.resid in plot.gam output object: partial residuals (working residuals + partial effect)
#the shift argument in plot.gam doesn't change output of partial residuals (p.resid)
#visreg generates the predictions as from plot.gam and predict.gam(type = "response") and mean covariates
#the partial residuals in visreg also follow the same pattern as p.resid in plot.gam output object, but with a difference of 0.4138:
#my guess is that visreg includes the intercept coefficient 0.3215 but p.resid does not (even though it is included on the plot due to the shift argument),
#but removing the intercept coefficient leaves the difference of 0.09237 (which seems to be the gap shown on the graphs)
#where does this come from?

# -- End of digression --

# Plot partial effects of fitted GAM (ignoring the digression) ----
plot_proj = visreg(forecast_gam, "project_used", type = "conditional", partial = T, jitter = F, gg = T) +
    scale_x_continuous(breaks = c(-10, -5, -1)) +
    scale_y_continuous(limits = c(0.15, 0.6)) +
    labs(title = "Project carbon loss",
         x = "Interval start (year)",
         y = "Partial effect") +
    theme_bw() +
    theme(panel.grid = element_blank(),
          plot.title = element_text(size = 22, hjust = 0.5),
          axis.title = element_text(size = 20),
          axis.text = element_text(size = 18))
plot_reg = visreg(forecast_gam, "region_used", type = "conditional", partial = T, jitter = T, gg = T) +
    scale_x_continuous(breaks = c(-10, -5, -1)) +
    labs(title = "Regional carbon loss",
         x = "Interval start (year)",
         y = "Partial effect") +
    theme_bw() +
    theme(panel.grid = element_blank(),
          plot.title = element_text(size = 22, hjust = 0.5),
          axis.title = element_text(size = 20),
          axis.text = element_text(size = 18))
plot_year = visreg(forecast_gam, "year", type = "conditional", partial = T, jitter = T, gg = T) +
    scale_x_continuous(breaks = c(1, 5, 10)) +
    labs(title = "Effect of forecasted interval",
         x = "Interval end (year)",
         y = "Partial effect") +
    theme_bw() +
    theme(panel.grid = element_blank(),
          plot.title = element_text(size = 24, hjust = 0.5),
          axis.title = element_text(size = 20),
          axis.text = element_text(size = 18))

title_forecasting = ggplot() +
    ggtitle("Effect of forecasting interval chosen to estimate:") +
    theme_void() + theme(plot.title = element_text(size = 24, hjust = 0.5, margin = margin(t = 10)))

#use patchwork to combine plots
design = "AAAAAAAAAA
          BBBBBBBBBB
          ##CCCCC###"
plot_forecasting = (plot_proj + plot_reg) +
    plot_layout(axis_titles = "collect_y")
(plot_all = title_forecasting / plot_forecasting / plot_year +
    plot_layout(design = design, heights = c(0.02, 1, 1)))
ggsave(plot_all, filename = paste0(fig_path, "forecast_5_gam_summ.png"), width = 30, height = 30, unit = "cm")